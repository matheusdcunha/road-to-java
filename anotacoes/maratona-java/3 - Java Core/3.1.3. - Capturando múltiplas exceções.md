Um único bloco `try` pode conter operações que lançam diferentes tipos de exceções, devemos ser capaz de responder a cada uma delas de forma apropriada. 

Temos duas abordagens para isso:

## Mútiplos Blocos `catch`

É a forma clássica e mais granular de tratar múltiplas execeções.

Você fornece um bloco `catch` para cada tipo de exceção específica que deseja tratar de maneira diferente.

```Java
import java.io.FileReader;
import java.io.IOException;
import java.util.Scanner;

public class ImportadorDeDados {

    public int lerIdadeDoArquivo(String caminhoArquivo) {
        try (FileReader reader = new FileReader(caminhoArquivo);
             Scanner scanner = new Scanner(reader)) {

            String conteudo = scanner.next();

            return Integer.parseInt(conteudo); 

        } catch (IOException e) {
            // Lógica específica para falha de I/O
            System.err.println("Erro de I/O: Não foi possível ler o arquivo. Verifique o caminho e as permissões.");
            // Retornar um valor padrão ou relançar
            return -1; 
        
        } catch (NumberFormatException e) {
            // Lógica específica para falha de formatação
            System.err.println("Erro de Formato: O conteúdo do arquivo não é um número válido.");
            // Retornar um valor padrão ou relançar
            return -2; 
        }
    }
}
```
Deve sempre capturar as exceções **mais específicas (subclasses) antes das mais genéricas (superclasses)**. 

Se você capturar `IOException` antes de `FileNotFoundException` (que é uma subclasse de `IOException`), o bloco de `FileNotFoundException` nunca será alcançado.

Essa abordagem é usada quando a lógica de recuperação para cada tipo de exceção for **diferente**.

## O bloco multi-catch

Você pode capturar múltiplos tipos de exceção em um único bloco `catch`, separando com uma barra vertical (`|`).

```Java
import java.io.IOException;
import java.text.ParseException;

public class ProcessadorDeConfiguracao {

    public void processar() throws FalhaNoProcessamentoException {
        try {
            // ... código que pode lançar IOException ...
            // ... código que pode lançar ParseException ...
            
        } catch (IOException | ParseException e) {
            System.err.println("Falha ao processar configuração: " + e.getMessage());
           
            throw new FalhaNoProcessamentoException("Não foi possível carregar a configuração.", e);
        }
    }
}

class FalhaNoProcessamentoException extends Exception {
    public FalhaNoProcessamentoException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

As exceções listadas em um bloco multi-catch não podem ter uma relação de herança entre si. 

O compilador proíbe `catch (FileNotFoundException | IOException e)` porque a segunda já abrange a primeira.

Essa abordagem deve ser usada quando a lógica de recuperação para exceções de ramos diferentes da hierarquia for **idêntica**.


