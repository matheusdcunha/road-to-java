As **Classes Wrappers**, são um conjunto de classes que abstraem os tipos primitivos adicionando métodos auxiliares e comportamentos.

|Tipo Primitivo|Classe Wrapper|
|---|---|
|`int`|`java.lang.Integer`|
|`double`|`java.lang.Double`|
|`char`|`java.lang.Character`|
|`boolean`|`java.lang.Boolean`|
|`long`|`java.lang.Long`|
|`float`|`java.lang.Float`|
|`short`|`java.lang.Short`|
|`byte`|`java.lang.Byte`|

Essencialmente, uma classe **Wrapper** "embrulha" um valor primitivo dentro de um objeto, permitindo que esse valor seja tratado como qualquer outro objeto no sistema.

## Wrappers e Tipos Primitivos

Se os primitivos são mais performáticos, por que precisamos de Wrappers?

### Coleções e Generics 

O framework de Coleções do Java, uma das APIs mais utilizadas, foi projetado para trabalhar exclusivamente com objetos.

O mecanismo de Generics, que garante a segurança de tipos (`type safety`), também só aceita tipos por referência.


```Java

List<Integer> idsDeProdutos = new ArrayList<>();
idsDeProdutos.add(101); 
// O valor 101 (int) é "embrulhado" em um objeto Integer.
idsDeProdutos.add(205);
idsDeProdutos.add(412);
```

*Sem a classe `Integer`, seria impossível criar uma lista de números inteiros com a segurança de tipos que os Generics oferecem.*

### Representação de Nulidade

Um tipo primitivo não pode ser nulo.

Uma variável `int` **não pode "não ter um valor"**, por padrão (se for um campo de uma classe), ela será inicializada com `0`. Isso pode ser problemático.

Imagine um campo `idade` em um formulário de cadastro que não é obrigatório.

- Se usarmos `int idade;`, como saberemos se o usuário não preencheu o campo ou se ele de fato digitou `0`?
- Usando `Integer idade;`, a distinção fica clara:
    
    - `idade = 0;` // O usuário informou a idade 0.
        
    - `idade = null;` // O usuário não informou a idade.
        

### Autoboxing

Para facilitar o trabalho com Wrappers, o Java introduziu um mecanismo de conversão automática chamado **autoboxing** (primitivo para Wrapper) e **unboxing** (Wrapper para primitivo).

```Java
Integer wrapperId = 100;

int primitivoId = wrapperId;

// Isso torna operações matemáticas transparentes:
wrapperId = wrapperId + 5;

// Ocorre: unboxing de wrapperId -> soma -> autoboxing do resultado para um novo Integer.
```

*Esse "açúcar sintático" torna o código muito mais limpo e legível.*

### Imutabilidade

Um ponto técnico crucial é que todos os objetos das classes Wrapper são **imutáveis**. Uma vez que um objeto `Integer` é criado com um valor, esse valor nunca mais pode ser alterado _dentro daquele objeto_.

Quando você faz `wrapperId = wrapperId + 5;`, você não está modificando o objeto `Integer` original. O que acontece é:

1. O `wrapperId` é desempacotado para o primitivo `100`.
    
2. A soma `100 + 5` é calculada, resultando em `105`.
    
3. Um **novo** objeto `Integer` é criado para conter o valor `105`.
    
4. A variável `wrapperId` passa a referenciar esse novo objeto.
    

*Essa característica garante que o estado de um objeto Wrapper seja sempre previsível, o que é fundamental em ambientes com múltiplas threads.*

## `==` & `.equals()`

Como Wrappers são objetos, a comparação com `==` verifica se duas referências apontam para o **mesmo objeto na memória**, enquanto o método `.equals()` verifica se os **valores internos são iguais**.


```Java
Integer x = 128;
Integer y = 128;
System.out.println(x == y);
// Saída: false (valores fora do cache, são objetos diferentes)

System.out.println(x.equals(y));
// Saída: true (os valores internos são os mesmos)
```

Sempre use `.equals()` para comparar o valor de objetos Wrapper.
