É uma classe que fornece as **regras para converter objetos de data/hora em `Strings` (formatação) e `Strings` de volta em objetos de data/hora (interpretação ou _parsing_)**.

Ela é a ferramenta que define como a informação temporal será representada como texto.

A classe `DateTimeFormatter` é **imutável e thread-safe**.

Esta é sua vantagem mais crítica sobre a antiga `SimpleDateFormat`.

Uma vez que um `DateTimeFormatter` é criado, ele não pode ser alterado. 

Você pode criar uma única instância e compartilhá-la com segurança por toda a sua aplicação (em múltiplas threads) sem risco de corrupção de dados.

## Criação com Factory Methods

Você não usa o construtor `new`. Em vez disso, a `DateTimeFormatter` oferece vários métodos de fábrica estáticos para obter uma instância, dependendo da sua necessidade.

- **Padrões Pré-definidos**: Fornece formatadores comuns, como o padrão ISO.
    
- `ofPattern()`: O mais utilizado. Cria um formatador a partir de um padrão de texto customizado.
    
- `ofLocalized...()`: Cria um formatador sensível ao `Locale`, que se adapta às convenções de uma região específica.
    

```Java
import java.time.format.DateTimeFormatter;
import java.time.format.FormatStyle;
import java.util.Locale;

// 1. Usando um padrão pré-definido (ISO_LOCAL_DATE é "AAAA-MM-DD")
DateTimeFormatter formatadorISO = DateTimeFormatter.ISO_LOCAL_DATE;

// 2. Criando a partir de um padrão customizado (o mais comum)
// 'dd' = dia, 'MM' = mês, 'yyyy' = ano, 'HH' = hora (0-23), 'mm' = minuto, 'ss' = segundo
DateTimeFormatter formatadorBrasileiro = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");

// 3. Criando a partir de um estilo localizado
// O Java saberá como escrever a data por extenso para o Brasil
DateTimeFormatter formatadorPorExtenso = DateTimeFormatter
    .ofLocalizedDateTime(FormatStyle.FULL)
    .withLocale(new Locale("pt", "BR"));
```

Isso nos leva a uma regra de ouro:

> Por ser thread-safe e imutável, a melhor prática é **declarar seus formatadores como constantes `public static final`**. Isso evita a recriação desnecessária de objetos e melhora a performance e a legibilidade do código.


```Java
public class Formatadores {
    public static final DateTimeFormatter DD_MM_YYYY = DateTimeFormatter.ofPattern("dd/MM/yyyy");
    public static final DateTimeFormatter YYYY_MM_DD_HH_MM = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
}
```

## Formatação e Interpretação (_Parsing_)

`DateTimeFormatter` opera em duas direções: transformando objetos em texto e texto em objetos.

### 1. Formatação (`Objeto -> String`)

Você usa o método `.format()` do objeto de data/hora, passando o formatador como argumento.

```Java
import java.time.LocalDateTime;

// Usando a hora e data atuais do contexto: Sábado, 11/10/2025, 11:13
LocalDateTime agora = LocalDateTime.now();

DateTimeFormatter fmtBr = DateTimeFormatter.ofPattern("dd/MM/yyyy 'às' HH:mm:ss");
DateTimeFormatter fmtExtenso = DateTimeFormatter
    .ofLocalizedDateTime(FormatStyle.FULL)
    .withLocale(new Locale("pt", "BR"));

String dataHoraFormatada = agora.format(fmtBr);
String dataPorExtenso = agora.format(fmtExtenso);

System.out.println("Formato brasileiro: " + dataHoraFormatada);
// Saída: Formato brasileiro: 11/10/2025 às 11:13:49

System.out.println("Formato por extenso: " + dataPorExtenso);
// Saída: Formato por extenso: sábado, 11 de outubro de 2025 11:13:49 BRT
```

### 2. Interpretação (_Parsing_) (`String -> Objeto`)

Você usa o método estático `.parse()` da classe de data/hora (`LocalDate`, `LocalDateTime`, etc.), passando a `String` e o formatador.

```Java
import java.time.LocalDate;
import java.time.format.DateTimeParseException;

String dataTexto = "07/09/1822";
DateTimeFormatter formatadorData = DateTimeFormatter.ofPattern("dd/MM/yyyy");

try {
    LocalDate independenciaDoBrasil = LocalDate.parse(dataTexto, formatadorData);
    System.out.println("Objeto LocalDate criado: " + independenciaDoBrasil);
    // Saída: Objeto LocalDate criado: 1822-09-07

} catch (DateTimeParseException e) {
    // ESSENCIAL: Ocorre se o texto não corresponder perfeitamente ao padrão
    System.err.println("Erro! O formato da data '" + dataTexto + "' é inválido.");
}
```

 Sua imutabilidade e thread-safety a tornam vastamente superior à antiga `SimpleDateFormat`, sendo a única escolha correta para formatação e interpretação de datas em aplicações Java modernas.