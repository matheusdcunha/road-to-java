É uma classe utilitária que **interpreta (faz _parsing_) de texto** a partir de uma fonte de entrada (como o teclado, um arquivo ou uma `String`) e o quebra em "tokens" (pedaços) que podem ser facilmente convertidos para tipos primitivos e `Strings`.

A classe `Scanner` é **mutável**.

Ela mantém um estado interno, que é a sua posição (um cursor) na fonte de entrada. Cada vez que você lê um dado (`.nextInt()`, `.nextLine()`, etc.), o `Scanner` avança seu cursor, e esse estado é permanentemente alterado.

Você não pode "voltar" na leitura.

## O Problema que o `Scanner` Resolve

Ler dados de uma fonte de entrada, como o teclado (`System.in`), não é uma tarefa trivial.

A entrada bruta é um `InputStream`, ou seja, um fluxo de bytes.

Sem o `Scanner`, você teria que ler byte por byte e manualmente construir lógicas para identificar onde um número termina, onde uma palavra começa, e como converter esses bytes para um `int` ou `double`.

```Java
// O JEITO ERRADO: extremamente complexo e manual
// (Código conceitual para ilustrar a dificuldade)
InputStreamReader reader = new InputStreamReader(System.in);
BufferedReader br = new BufferedReader(reader);

String linha = br.readLine();
// Lê a linha inteira
int numero = Integer.parseInt(linha);
// Converte para int, mas falha se tiver mais de uma coisa na linha
```

*Isso é frágil e complicado. O `Scanner` foi projetado para esconder toda essa complexidade.*

**A forma correta com `Scanner`:**

```Java
import java.util.Scanner;

// O Scanner é ligado à fonte de entrada (neste caso, o teclado)
Scanner scanner = new Scanner(System.in);

System.out.print("Digite seu nome: ");
String nome = scanner.next();
// Lê a próxima palavra

System.out.print("Digite sua idade: ");
int idade = scanner.nextInt();
// Lê o próximo inteiro

System.out.println("Olá, " + nome + "! Você tem " + idade + " anos.");

scanner.close();
// ESSENCIAL: fechar o scanner para liberar o recurso
```

Isso nos leva a uma regra de ouro:

> Por gerenciar um recurso subjacente (como um `InputStream` de um arquivo ou do sistema), um `Scanner` **deve sempre ser fechado** para evitar vazamentos de recursos. A forma mais segura e moderna de garantir isso é usando um bloco **`try-with-resources`**.

```Java
// A melhor prática profissional para usar o Scanner
try (Scanner scanner = new Scanner(System.in)) {
    System.out.print("Digite seu CEP: ");
    String cep = scanner.nextLine();
    System.out.println("CEP digitado: " + cep);
}
// O scanner é fechado automaticamente aqui, mesmo que ocorra um erro.
```

## O Dilema Comum: `nextInt()` seguido de `nextLine()`

Este é o problema mais famoso e que mais confunde iniciantes. O `Scanner` quebra a entrada com base em um delimitador (por padrão, o espaço em branco).

O Problema:

Quando você digita um número e aperta Enter, você envia para o Scanner algo como "42\n" (\n é o caractere de nova linha).

1. O método `.nextInt()` lê apenas os caracteres numéricos (`"42"`), converte para `int` e deixa o `\n` para trás, no buffer de entrada.
    
2. A chamada seguinte a `.nextLine()` encontra esse `\n` imediatamente, interpreta como "o usuário digitou uma linha vazia" e a consome, sem dar a chance de você digitar o que queria.
    

**Exemplo do Bug:**

```Java
try (Scanner scanner = new Scanner(System.in)) {
    System.out.print("Digite sua idade: ");
    int idade = scanner.nextInt();
	// Lê "42", deixa "\n"

    System.out.print("Digite seu nome completo: ");
    String nome = scanner.nextLine();
	// Lê o "\n" restante e não espera sua entrada

    System.out.printf("Idade: %d, Nome: '%s'%n", idade, nome);
    // Saída: Idade: 42, Nome: ''
}
```

A Solução Correta (e mais robusta):

A melhor abordagem é ler toda a entrada linha por linha com .nextLine() e, então, fazer a conversão (parsing) manualmente.

Isso dá a você total controle sobre a entrada e evita o problema do \n.

```Java
try (Scanner scanner = new Scanner(System.in)) {
    System.out.print("Digite sua idade: ");
    // Lê a linha inteira "42" e consome o "\n"
    String linhaIdade = scanner.nextLine();
    int idade = Integer.parseInt(linhaIdade);
    // Converte a String para int

    System.out.print("Digite seu nome completo: ");
    String nome = scanner.nextLine();
    // Agora funciona como esperado

    System.out.printf("Idade: %d, Nome: '%s'%n", idade, nome);
    // Saída: Idade: 42, Nome: 'Fulano de Tal'
}
```
Embora seja simples de usar para tarefas básicas, é crucial gerenciar seus recursos corretamente com `try-with-resources` e entender o comportamento de seus métodos (especialmente `nextInt` vs. `nextLine`) para evitar bugs comuns.