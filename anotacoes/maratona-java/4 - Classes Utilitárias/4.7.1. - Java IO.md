Este é o fundamento do I/O em Java.

Sua principal característica é ser **bloqueante (blocking)**.

Quando você solicita uma operação de leitura, por exemplo, a **thread que fez a chamada ficará bloqueada**, aguardando até que os dados estejam disponíveis.

Este modelo é **simples e direto.**

Para **operações sequenciais e lineares**, como ler um arquivo de configuração do início ao fim, ele é perfeitamente adequado e fácil de raciocinar.

## **Abstrações Fundamentais:**

A API `java.io` se divide em duas hierarquias principais, baseadas no tipo de dado que está sendo trafegado:

- **Byte Streams (`InputStream` / `OutputStream`)**: Utilizados para manipular dados binários brutos (arquivos de imagem, executáveis, áudio, etc.). A unidade fundamental é o `byte`.
    <br>
- **Character Streams (`Reader` / `Writer`)**: Utilizados para manipular dados de texto (arquivos `.txt`, `.csv`, `.json`, etc.). A unidade fundamental é o `char`, e eles lidam internamente com a complexidade de _character encodings_ (como UTF-8), prevenindo problemas de corrupção de caracteres.
    

## **O Padrão Decorator em Ação:**

Uma das características mais poderosas (e inicialmente confusas) do `java.io` é o uso extensivo do padrão de projeto _Decorator_.

Você "envelopa" um stream básico com outras classes para adicionar funcionalidades.

**Cenário Prático:** Ler um arquivo de log linha por linha de forma eficiente.



```Java
// NÃO FAÇA ISSO EM PRODUÇÃO - Ineficiente para arquivos grandes
try (FileInputStream fis = new FileInputStream("application.log")) {
    int byteData;
    while ((byteData = fis.read()) != -1) {
        // Processa byte a byte... lento e complexo.
    }
} catch (IOException e) {
    // Tratamento de exceção robusto é mandatório.
    e.printStackTrace();
}

// A FORMA CORRETA E PROFISSIONAL
try (BufferedReader reader = new BufferedReader(new FileReader("application.log"))) {
    String line;
    while ((line = reader.readLine()) != null) {
        // Processa a linha, ex: "2025-10-11 13:07:04 INFO - User service initialized."
        System.out.println(line);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

- **Análise do Exemplo:**
    
    - `FileReader` é o `Reader` base que sabe como ler caracteres de um arquivo no disco.
        <br>
    - `BufferedReader` é um _Decorator_. Ele "envolve" o `FileReader` e adiciona a funcionalidade de _buffering_ (leitura em blocos maiores para a memória), o que aumenta drasticamente a performance, além de fornecer o método utilitário `readLine()`.
        <br>
- **Quando Usar `java.io` Hoje?** Para operações de I/O simples e sequenciais onde o bloqueio da thread não é um problema crítico. Ler arquivos de configuração, scripts de inicialização, ou logs para análise são casos de uso comuns.