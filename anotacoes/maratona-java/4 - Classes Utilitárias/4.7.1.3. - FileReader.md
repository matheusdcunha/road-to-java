Assim como `File` é apenas um ponteiro para um caminho, `FileReader` não armazena o texto do arquivo em memória.

Ele é um **fluxo de leitura de caracteres (`Reader`)** que se conecta a um arquivo no sistema de arquivos.

Sua função é ler os bytes do arquivo e decodificá-los em caracteres (`char`) que o Java pode entender, usando a codificação de caracteres padrão do sistema operacional.

A classe `FileReader` é **mutável e stateful**.

Ela mantém um estado interno crucial: um "cursor" que indica a posição atual da leitura dentro do arquivo.

Cada vez que você lê um caractere ou um conjunto de caracteres, esse cursor avança. Você não pode "voltar" ou reler um trecho facilmente; é um fluxo de leitura sequencial. 

Por gerenciar um recurso do sistema (o "file handle"), seu fechamento correto é mandatório.


```Java
// O JEITO VERBOSO E NÃO RECOMENDADO
FileReader reader = null;
try {
    reader = new FileReader("poema.txt");
    int caractere; 
    // .read() retorna um int (o valor do char, ou -1 no fim)
    
    // Lê o arquivo caractere por caractere... muito ineficiente!
    while ((caractere = reader.read()) != -1) {
        System.out.print((char) caractere);
    }
} catch (IOException e) {
    e.printStackTrace();
} finally {
    // Fechamento manual é complexo e pode falhar
    if (reader != null) {
        try {
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

Isso nos leva a uma regra de ouro:

> Por ser um recurso que precisa ser fechado, a única forma correta e segura de usar `FileReader` é com um bloco **`try-with-resources`**. Além disso, ler do disco caractere por caractere é extremamente lento. A prática profissional é sempre "envelopar" o `FileReader` em um **`BufferedReader`**.

## A Prática Profissional: `FileReader` + `BufferedReader`

O `BufferedReader` otimiza drasticamente a leitura.

Ele lê um grande bloco de dados do arquivo para um buffer na memória de uma só vez.

As suas chamadas de leitura subsequentes consomem dados desse buffer rápido, em vez de acessar o disco lento a todo momento.

Ele também fornece o método extremamente útil `.readLine()`, que lê uma linha inteira de texto, algo que o `FileReader` sozinho não consegue fazer.

**A Combinação Perfeita (O Jeito Certo e Eficiente):**

```Java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class LeituraEficiente {

    public static void main(String[] args) {
        String caminhoDoArquivo = "artigo.txt";

        // O try-with-resources garante que ambos os leitores serão fechados.
        try (
            FileReader fr = new FileReader(caminhoDoArquivo);
            BufferedReader br = new BufferedReader(fr)
        ) {
            String linha;
            int numeroLinha = 1;

            System.out.println("--- Conteúdo do Arquivo: " + caminhoDoArquivo + " ---");
            
            // Este é o loop padrão para ler um arquivo de texto linha por linha.
            while ((linha = br.readLine()) != null) {
                System.out.printf("%d: %s%n", numeroLinha++, linha);
            }

        } catch (IOException e) {
            System.err.println("Falha ao ler o arquivo: " + e.getMessage());
        }
    }
}
```