**`Strings`** **não são um tipo primitivo** no Java.

É uma classe, cada variável do tipo `String` é uma referência a um objeto que representa uma sequência de caracteres.

A classe `String` é **imutável**. 

Uma vez que um objeto é criado, ele não pode ser mais alterado. Qualquer método que pareça modificar uma string, na verdade, retorna um **novo objeto** `String` com a modificação aplicada, enquanto o original permanece intacto

## String Pool e Criação de Strings

Para economizar memória, a JVM mantém uma área especial na memória heap chamada "String Pool" (ou "String Intern Pool").

Quando você cria uma string de forma literal, a JVM verifica se uma string com aquele mesmo conteúdo já existe no pool:

- Se sim, ela simplesmente retorna a referência para o objeto já existente.
- Se não, ela cria o novo objeto `String` no pool e retorna sua referência.

```Java
String nome1 = "Java";
 // "Java" não está no pool. É criado e nome1 aponta para ele.
String nome2 = "Java";
 // "Java" já existe no pool. nome2 aponta para o MESMO objeto que nome1.

//Usar o construtor explicitamente FORÇA a criação de um novo objeto fora do pool.
String nome3 = new String("Java"); 

// Verificando as referências de memória com '=='
System.out.println(nome1 == nome2);
 // Saída: true (apontam para o mesmo objeto no pool)
System.out.println(nome1 == nome3);
 // Saída: false (nome3 é um objeto distinto no heap)
```

Isso nos leva a uma regra de ouro:

> Para comparar o _conteúdo_ de duas strings, a única forma correta e segura é utilizando o método `.equals()`. O operador `==` compara a referência de memória dos objetos, o que raramente é o que você deseja fazer.

```Java
System.out.println(nome1.equals(nome3));
```

## String Builder

A forma mais comum de juntar strings é com o operador `+`.

```Java
String info = "Usuário: " + nome + " (ID: " + id + ")";
```

Para operações simples, isso é perfeitamente aceitável. O compilador Java é inteligente e, por baixo dos panos, converte isso em código mais otimizado.

O problema surge ao concatenar strings dentro de um laço (`loop`).

```Java
String[] itens = {"item1", "item2", "item3"};
String listaCsv = "";
for (String item : itens) {
    listaCsv += item + ",";
     // A cada iteração, um novo objeto String é criado e o antigo descartado.
}
```
*Isso é terrivelmente ineficiente, pois a cada passo do loop, a JVM precisa criar um novo objeto `String` e alocar memória para ele, gerando muito lixo a ser coletado pelo Garbage Collector.*

Para construção de strings de forma programática ou em loops, a ferramenta correta é a classe `StringBuilder`. Ela representa uma string **mutável**.

```Java

StringBuilder builder = new StringBuilder();
for (String item : itens) {
    builder.append(item);
    builder.append(",");
}
String listaCsvFinal = builder.toString();
// Converte para uma String imutável no final.
```

`StringBuilder` modifica seu buffer interno sem criar novos objetos a cada chamada de `.append()`, tornando o processo ordens de magnitude mais rápido e eficiente.