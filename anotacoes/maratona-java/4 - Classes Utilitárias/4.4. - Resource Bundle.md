
É uma classe que representa um **conjunto de recursos localizados**. Na prática, ela desacopla o texto visível ao usuário do código-fonte, carregando-o de arquivos externos (`.properties`) com base no `Locale` do usuário.

Os `ResourceBundle`s são essencialmente **dados de configuração**.

Eles são carregados uma vez e consultados como um mapa de chave-valor, sendo tratados como dados somente leitura.

## Externalizando o Texto da Aplicação

O problema fundamental que o `ResourceBundle` resolve é o texto "chumbado" (hardcoded) no código.

```Java
// O JEITO ERRADO: difícil de traduzir e manter
System.out.println("Bem-vindo ao sistema!");
```

Tentar adicionar um novo idioma com essa abordagem levaria a um código insustentável cheio de `if/else`. 

A solução é mover todo o texto para arquivos de propriedades.

#### Passo 1: Crie os arquivos de recursos

Em src/main/resources, crie um arquivo base e suas traduções:

**`messages.properties` (Padrão/Inglês)**


```Properties
login.title=Login Screen
login.button=Sign In
```

**`messages_pt_BR.properties` (Português do Brasil)**


```Properties
login.title=Tela de Login
login.button=Entrar
```

#### **Passo 2: Carregue o arquivo correto com base no Locale**

```Java
import java.util.Locale;
import java.util.ResourceBundle;

Locale localeDoUsuario = new Locale("pt", "BR");

// O Java procura por "messages_pt_BR.properties" automaticamente
ResourceBundle messages = ResourceBundle.getBundle("messages", localeDoUsuario);

String titulo = messages.getString("login.title");
String botao = messages.getString("login.button");

System.out.println(titulo); // Saída: Tela de Login
System.out.println(botao);  // Saída: Entrar
```

Isso nos leva a uma regra de ouro:

> Sempre forneça um `ResourceBundle` padrão (sem sufixo, ex: `messages.properties`). Ele servirá como um **fallback** seguro caso a aplicação seja executada em um `Locale` para o qual você não forneceu uma tradução, evitando que o programa quebre.

```Java
// Usuário com Locale alemão, para o qual não temos tradução
Locale localeAlemao = Locale.GERMAN;

// O Java não encontra "messages_de.properties", então ele usa o padrão "messages.properties"
ResourceBundle messages = ResourceBundle.getBundle("messages", localeAlemao);

String titulo = messages.getString("login.title");
System.out.println(titulo);
// Saída: Login Screen (do arquivo padrão)
```

## Textos Dinâmicos com `MessageFormat`

Frequentemente, o texto precisa incluir valores variáveis, como um nome de usuário.

```Java
// O JEITO ERRADO: misturando texto e variáveis no código
String welcomeMessage = "Bem-vindo, " + username + "!";
```

_Isso torna a tradução extremamente difícil, pois a ordem das palavras e a gramática mudam entre os idiomas. A solução é usar placeholders nos arquivos de propriedades._

A ferramenta correta para isso é a classe `MessageFormat`, que substitui placeholders (`{0}`, `{1}`, etc.) por valores dinâmicos.

**`messages_pt_BR.properties`**

```Properties
welcome.user=Bem-vindo(a), {0}! Você tem {1} novas mensagens.
```

**`messages.properties`**

```Properties
welcome.user=Welcome, {0}! You have {1} new messages.
```

**Código Java:**

```Java
import java.text.MessageFormat;

ResourceBundle messages = ResourceBundle.getBundle("messages", new Locale("pt", "BR"));

String username = "Maria";
int messageCount = 5;

// Pega o template do arquivo de propriedades
String welcomeTemplate = messages.getString("welcome.user");

// Usa o MessageFormat para injetar os valores
String formattedMessage = MessageFormat.format(welcomeTemplate, username, messageCount);

System.out.println(formattedMessage);
// Saída: Bem-vindo(a), Maria! Você tem 5 novas mensagens.
```