**`LocalDate`** **não representa um instante no tempo**.

É uma classe que representa uma **data sem hora e sem fuso horário** (apenas ano, mês e dia).

A classe `LocalDate` é **imutável**.

## Criação com Factory Methods

Diferente de classes mais antigas, `LocalDate` não é criada com um construtor `new`. Em vez disso, você utiliza métodos de fábrica estáticos (`static factory methods`) que tornam o código mais legível.

Existem três formas principais de criar uma `LocalDate`:

- `now()`: Pega a data atual do relógio do sistema.
    
- `of()`: Cria uma data a partir de valores de ano, mês e dia.
    
- `parse()`: Interpreta uma `String` para criar uma data.
    

```Java
// 1. Pega a data atual (baseada no relógio do sistema)
LocalDate hoje = LocalDate.now();

// 2. Cria uma data específica
LocalDate natal = LocalDate.of(2025, 12, 25);
// Usar o enum Month deixa o código ainda mais claro
LocalDate anoNovo = LocalDate.of(2026, java.time.Month.JANUARY, 1);

// 3. Interpreta uma String. O padrão (AAAA-MM-DD) não precisa de formatador.
LocalDate diaDoTrabalho = LocalDate.parse("2026-05-01");

System.out.println("Hoje: " + hoje);
// Saída: 2025-10-11
System.out.println("Natal: " + natal);
// Saída: 2025-12-25
System.out.println("Dia do Trabalho: " + diaDoTrabalho);
// Saída: 2026-05-01
```

Isso nos leva a uma regra de ouro:

> Para comparar o _valor cronológico_ de duas datas, a forma correta e segura é utilizando os métodos `.isBefore()`, `.isAfter()` e `.isEqual()`. Eles expressam a intenção do código de forma muito clara.


```Java
LocalDate hoje = LocalDate.now(); // 2025-10-11
LocalDate ontem = LocalDate.of(2025, 10, 10);

System.out.println(ontem.isBefore(hoje)); // Saída: true
System.out.println(hoje.isAfter(ontem));  // Saída: true
System.out.println(hoje.isEqual(hoje));  // Saída: true
```

## Manipulação de Datas

Com a antiga API (`Calendar`), modificar datas era uma tarefa verbosa e propensa a erros.

```Java
// JEITO ANTIGO E VERBOSO (NÃO RECOMENDADO)
Calendar c = Calendar.getInstance();
c.add(Calendar.DAY_OF_MONTH, 10);
Date dataFutura = c.getTime();
```

_Isso é ineficiente e perigoso, pois o objeto `Calendar` é mutável, o que pode causar bugs inesperados em outras partes do sistema que usam a mesma referência._

Para manipular datas de forma programática, a ferramenta correta são os métodos da própria classe `LocalDate`. Eles utilizam uma API fluente e retornam sempre um novo objeto.

```Java
LocalDate hoje = LocalDate.now(); // 2025-10-11

// Cada método retorna uma NOVA instância de LocalDate
LocalDate umaSemanaAtras = hoje.minusWeeks(1);
LocalDate proximoMes = hoje.plusMonths(1);

// Os métodos podem ser encadeados
LocalDate primeiroDiaDoProximoAno = hoje.plusYears(1)
                                        .withMonth(1)
                                        .withDayOfMonth(1);

System.out.println("Uma semana atrás: " + umaSemanaAtras);
// Saída: 2025-10-04
System.out.println("Próximo mês: " + proximoMes);
// Saída: 2025-11-11
System.out.println("Primeiro dia de 2027: " + primeiroDiaDoProximoAno); // Saída: 2027-01-01
```

Os métodos `plus` e `minus` da `LocalDate` modificam a data de forma segura e previsível, sem efeitos colaterais, tornando o código muito mais robusto e fácil de ler.