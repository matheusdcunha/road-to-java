Ele é uma classe do tipo **Decorator** (ou "Wrapper").

Sua principal função é "envelopar" outro `Reader` (como um `FileReader`) para adicionar uma camada de **buffering de memória**.

Ele não se conecta diretamente a um arquivo; em vez disso, ele puxa grandes blocos de dados do `Reader` que ele envolve, armazenando-os em um buffer interno para acelerar as operações de leitura subsequentes.

A classe `BufferedReader` é **mutável e stateful**.

Ela gerencia um buffer interno (geralmente um array de caracteres) e mantém ponteiros para a posição atual de leitura dentro desse buffer.

Cada vez que você lê dados, o `BufferedReader` primeiro tenta satisfazer a solicitação a partir do seu buffer rápido. Somente quando o buffer está vazio é que ele realiza uma operação de leitura cara no `Reader` subjacente para reabastecê-lo.

## O Problema que o `BufferedReader` Resolve

Assim como na escrita, ler do disco é uma operação extremamente lenta. Usar um `FileReader` puro e seu método `.read()` significa pedir ao sistema operacional para ler do disco **um caractere de cada vez**. Para um arquivo de texto de 1MB (aproximadamente 1 milhão de caracteres), isso poderia resultar em 1 milhão de operações de I/O, o que seria terrivelmente lento.

```Java
// O JEITO INEFICIENTE: Múltiplos acessos ao disco para ler caractere por caractere.
try (FileReader reader = new FileReader("livro_grande.txt")) {
    int caractere;
    // Cada chamada a .read() pode, em teoria, causar uma leitura no disco.
    while ((caractere = reader.read()) != -1) {
        // processa o caractere...
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

O `BufferedReader` resolve esse gargalo de performance de forma drástica. Em sua primeira leitura, ele preenche seu buffer interno com um grande bloco de texto (por exemplo, 8KB).

As suas chamadas seguintes ao `.read()` simplesmente pegam caracteres sequencialmente desse buffer na memória RAM, que é ordens de magnitude mais rápido. Apenas quando o buffer se esgota é que ocorre outro acesso ao disco.

Isso nos leva a uma regra de ouro:

> Assim como na escrita, você quase nunca deve usar um `FileReader` diretamente. **Sempre envolva-o em um `BufferedReader`**. Além da performance, ele fornece o método indispensável `.readLine()`, que é a maneira padrão e mais conveniente de processar arquivos de texto.

## A Prática Profissional: O Padrão Canônico de Leitura

A forma correta e universalmente aceita de ler um arquivo de texto em Java I/O clássico é combinar `FileReader` e `BufferedReader` dentro de um bloco `try-with-resources`, usando o método `.readLine()` em um loop.

1. **`FileReader`**: Conecta-se ao arquivo físico no disco.
    
2. **`BufferedReader`**: Adiciona o buffer de memória para performance e fornece o método `.readLine()`.
    

**A Combinação Perfeita (O Jeito Certo):**

```Java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class LeituraOtimizada {

    public static void main(String[] args) {
        String caminhoDoArquivo = "config.properties";

        // O try-with-resources garante que ambos os fluxos serão fechados.
        try (
            FileReader fr = new FileReader(caminhoDoArquivo);
            BufferedReader br = new BufferedReader(fr)
        ) {
            String linha;
            System.out.println("Lendo configurações do arquivo: " + caminhoDoArquivo);
            
            // Este é o loop idiomático para ler um arquivo de texto até o fim.
            // O .readLine() retorna a linha de texto ou 'null' quando chega ao final do arquivo.
            while ((linha = br.readLine()) != null) {
                // Ignora linhas de comentário ou linhas em branco
                if (!linha.startsWith("#") && !linha.trim().isEmpty()) {
                    System.out.println("Configuração encontrada: " + linha);
                }
            }
        } catch (IOException e) {
            // Trata exceções como "Arquivo não encontrado" ou erros de leitura.
            System.err.println("Erro ao processar o arquivo de configuração: " + e.getMessage());
        }
    }
}
```

### O Poder do `.readLine()`

O método `.readLine()` é a principal razão pela qual o `BufferedReader` é tão essencial. Ele faz o trabalho pesado de:

- Ler caracteres do buffer até encontrar um caractere de quebra de linha (`\n`), um retorno de carro (`\r`), ou uma combinação dos dois.
    
- Montar esses caracteres em uma `String`.
    
- Retornar a `String` sem os caracteres de quebra de linha.
    
- Retornar `null` quando não há mais nada a ser lido, sinalizando o fim do arquivo de forma clara e simples para ser usado como condição de parada em um loop `while`.
    

Ao adicionar um buffer de memória e o método de conveniência `.readLine()`, ele transforma a tarefa de ler arquivos, que seria ineficiente e complexa, em um processo simples, rápido e padronizado.